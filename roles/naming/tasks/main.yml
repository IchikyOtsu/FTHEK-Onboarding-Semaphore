---
# Tasks pour la génération de noms uniques

- name: Lire le fichier d'inventaire existant s'il existe
  slurp:
    src: "{{ inventaire_path | default(inventory_dir + '/hosts.yml') }}"
  register: inventaire_slurp
  ignore_errors: yes
  delegate_to: localhost

- name: Extraire les machines déjà listées (ou vide si fichier manquant)
  set_fact:
    inventaire_connu: >-
      {{
        (
          inventaire_slurp.content | b64decode | split('\n')
          | reject('match', '^\[.*\]')
          | reject('equalto', '')
          | map('regex_replace', '\.fonteynethekitchen\.local$', '')
          | list
        )
        if (
          inventaire_slurp is defined and
          inventaire_slurp.failed is not defined and
          'content' in inventaire_slurp
        ) else []
      }}
  delegate_to: localhost

- name: Fusionner sans doublon avec noms AD
  set_fact:
    inventaire_fusionne: "{{ (inventaire_connu + noms_machines_ad) | unique | sort }}"
  delegate_to: localhost

- name: Définir le préfixe de nom
  set_fact:
    prefix: "{{ departement }}-{{ type_machine }}"
  delegate_to: localhost

- name: Extraire les noms correspondant au modèle
  set_fact:
    existants: "{{ inventaire_fusionne | select('match', '^' ~ prefix ~ '-\\d{3}$') | list }}"
  delegate_to: localhost

- name: Extraire les IDs utilisés
  set_fact:
    existants_ids: "{{ existants | map('regex_replace', '^' ~ prefix ~ '-(\\d{3})$', '\\1') | map('int') | list }}"
  delegate_to: localhost

- name: Générer le plus petit ID libre et le nom final
  set_fact:
    new_hostname: >-
      {{
        prefix ~ '-' ~ (
          (range(1, 1000) | difference(existants_ids | default([])) | min)
          | string | regex_replace('^(\\d)$', '00\\1')
                  | regex_replace('^(\\d{2})$', '0\\1')
        )
      }}
  delegate_to: localhost

- name: Afficher le nom généré (optionnel, activé si debug_mode est vrai)
  debug:
    msg: "Nom disponible généré : {{ new_hostname }}"
  when: debug_mode | default(false) 